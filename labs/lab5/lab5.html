<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.56">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Lab 5 – E155 Portfolio</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">E155 Portfolio</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-labs" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Labs</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-labs">    
        <li>
    <a class="dropdown-item" href="../../labs/lab1/lab1.html">
 <span class="dropdown-text">Lab 1 - FPGA &amp; MCU Setup &amp; Testing</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../labs/lab2/lab2.html">
 <span class="dropdown-text">Lab 2 - Multiplexed 7-Segment Display</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../labs/lab3/lab3.html">
 <span class="dropdown-text">Lab 3 - Keypad Scanner</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../labs/lab4/lab4.html">
 <span class="dropdown-text">Lab 4 - Digital Audio</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../labs/lab5/lab5.html">
 <span class="dropdown-text">Lab 5 - Interrupts</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../labs/lab6/lab6.html">
 <span class="dropdown-text">Lab 6 - IoT &amp; SPI</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../labs/lab7/lab7.html">
 <span class="dropdown-text">Lab 7 - Advanced Encryption Standard</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="../../blog.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../resources.html"> 
<span class="menu-text">Resources</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://www.github.com/jacksonphilion"> 
<span class="menu-text">Github</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#lab-5-interrupts" id="toc-lab-5-interrupts" class="nav-link active" data-scroll-target="#lab-5-interrupts">Lab 5: Interrupts</a></li>
  <li><a href="#lab-task-read-in-a-motors-encoder-for-rpm" id="toc-lab-task-read-in-a-motors-encoder-for-rpm" class="nav-link" data-scroll-target="#lab-task-read-in-a-motors-encoder-for-rpm">Lab Task: Read in a Motor’s Encoder for RPM</a></li>
  <li><a href="#understanding-the-hardware" id="toc-understanding-the-hardware" class="nav-link" data-scroll-target="#understanding-the-hardware">Understanding the Hardware</a></li>
  <li><a href="#introducing-interrupts" id="toc-introducing-interrupts" class="nav-link" data-scroll-target="#introducing-interrupts">Introducing: Interrupts</a></li>
  <li><a href="#microcontroller-block-diagram-and-schematic" id="toc-microcontroller-block-diagram-and-schematic" class="nav-link" data-scroll-target="#microcontroller-block-diagram-and-schematic">Microcontroller Block Diagram and Schematic</a></li>
  <li><a href="#testing-the-system" id="toc-testing-the-system" class="nav-link" data-scroll-target="#testing-the-system">Testing the System</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Lab 5</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p><strong>Quick Stats</strong><br>
Time Spent: 14 Hours, iStoppedCounting minutes and seconds<br>
Timers Initialized: 2 - 1 = 1<br>
Consistent Surprise (you’ll see): 22%<br>
CMSIS: Used Effectively<br>
Times I Asked Javier to Borrow the Tachometer: 1 (he just let me have it)<br>
Individual Tachometer Measurements: &gt;100 (thanks Javier!)<br>
DC Motors in the Lab: Too Hard to Find<br>
Overall: Success<br>
</p>
<section id="lab-5-interrupts" class="level2">
<h2 class="anchored" data-anchor-id="lab-5-interrupts">Lab 5: Interrupts</h2>
<div class="quarto-video ratio ratio-16x9"><iframe data-external="1" src="https://www.youtube.com/embed/_b0u2pK0MaQ" title="" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div>
</section>
<section id="lab-task-read-in-a-motors-encoder-for-rpm" class="level2">
<h2 class="anchored" data-anchor-id="lab-task-read-in-a-motors-encoder-for-rpm">Lab Task: Read in a Motor’s Encoder for RPM</h2>
<p>In this lab, students were tasked with obtaining the rotational speed of a DC motor using a built-in encoder. After determining this speed, students printed it out to the user in a method of their choosing.</p>
</section>
<section id="understanding-the-hardware" class="level2">
<h2 class="anchored" data-anchor-id="understanding-the-hardware">Understanding the Hardware</h2>
<p>I was completely unfamiliar with quadrature encoders before this lab, but have rapidly come to recognize their utility. Professor Joshua Brake created the following animation, in <a href="#fig-encoder" class="quarto-xref">Figure&nbsp;1</a>, to describe their behavior. It can be found in the prompt for Lab 5 <a href="https://hmc-e155.github.io/lab/lab5/#fig-quadrature-encoder">here</a>. I found it to be the most effective tool for gaining an understanding.</p>
<p>This diagram shows the waveforms generated by our DC motor’s encoder, which consists of two lines: an A and a B. Using just these offset waveforms, one can determine both the rotational speed and direction of the motor. Finding the speed is easy – it’s directly linked to the frequency of the wave. In <a href="#fig-encoder" class="quarto-xref">Figure&nbsp;1</a>, a single rotation contains 6 dark and 6 light sectors, generating 6 rising edges and 6 falling edges on the waveforms A and B. By counting the time between edges, whether one counts between two or waits for a full cycle of twelve, one can manipulate this value to determine the revolutions per second of the motor. Alternatively, by counting the amount of edges in a given amount of time, one can similarly determine the motor’s rotational velocity.</p>
<div id="fig-encoder" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-encoder-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/quadrature_encoder.gif" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-encoder-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1: Quadrature Encoder Diagram Animation, from Professor Joshua Brake <a href="https://hmc-e155.github.io/lab/lab5/#fig-quadrature-encoder">here</a>
</figcaption>
</figure>
</div>
<p>The direction, on the other hand, is less straightforward. It may not be immediately obvious how one can track the direction just from these alternating waveforms. The key idea is that the offset between the two waves generates a unique pattern which depends on the direction of spin. This is easiest for me to visualize if I track a single trough on the lower B waveform. You’ll notice that within the bounds of one of these low B troughs, the A wave is low on the left portion and high on the right. Focus in on the left portion of the trough – here, the B wave is low <em>and</em> the A wave is low. Track one of these points of low-low. Imagine that the motor came to a standstill on one of these points, and the animation stopped moving. If you were looking from within this low-low trough, you would see an B waveform high to the left, and an A waveform high to the right. Either direction you spin the motor, you would run into one, and only one, of these rising edges first. This is how one can track motor direction.</p>
<p>Put another way, the encoder’s current state is listed like a coordinate pair, {AB}, where a low-low trough is represented as {00}. No matter the current state, whether it be {00}, {01}, {10}, or {11}, there are only two possible next states. Each possibility corresponds to a different direction.</p>
<p>Great! So, if we track the timing of the waveform edges, we get rotational velocity – if we track the state of each wave, we get motor direction. How do we translate this into C code which we can implement on a microcontroller (MCU)?</p>
</section>
<section id="introducing-interrupts" class="level2">
<h2 class="anchored" data-anchor-id="introducing-interrupts">Introducing: Interrupts</h2>
<p>Fundamentally, the question is how best to track these edge changes. There are two broad categories which describe the two different fundamental implementations – a solution either uses interrupts or polling. Polling is the easier to implement. One could track the edges by “looking” at the signal at a set interval. For example, one could check the status of the encoder every 10 milliseconds, thus constructing a discrete graph of the signal over time. This is much like we programmed into our Lab 3 keyboard scanner, which checked every row of the keypad for a millisecond. Detection was not instantaneous – it relied on a polling time that was fast enough to pick up inputs “as if” in real time.</p>
<p>Interrupts, on the other hand, are more difficult to implement on an MCU. However, they can be more useful when a precise response to real-time inputs is required. Instead of relying on the central processing unit (CPU) to track a timer and poll the input, a dedicated peripheral watches for changes. This peripheral then reports changes to the CPU, which temporarily pauses its main task to handle the generated “interrupt” before returning to its previous function. In this way, one can track the status of a wave as it changes in real time, while at the same time leaving the CPU to handle other tasks along the way.</p>
<p>When choosing between the two, I should first state that I always planned to use interrupts for this lab – after all, that was a core learning goal. However, I believe that it represents the better choice in this case because it is the only way to construct a full, non-discrete image of the waveform. I use non-discrete loosely here, because we are still limited to checking for an interrupt on every CPU clock cycle, but the key point is that we can track changes with for more accuracy than we could in a polling system. By only checking for changes in the system, we can construct a much fuller picture while reducing CPU overhead. Note, however, that there is a limit. We can only log our edges as fast as our CPU can process interrupts. This case happens to work well, since I calculate that we might generate up to 5000 interrupts a second, leaving &gt;3,500 clock cycles between interrupts. If we were to generate a million interrupts a second, on the other hand, then my interrupt-handling code is likely too long to keep up. My printing code in the main loop would never run, and I would under-count generated edges. This could be partially fixed by interrupt-proofing my print loop, or by making the timer generate a higher priority interrupt to print, but neither of these measures were necessary for my relatively slow case. Additionally, interrupts work well here because I am only expecting one signal to change at any one time. I would need to fundamentally redesign my system if I was expecting a sudden influx of signals changing in parallel, since each interrupt change would be backlogged behind another. However, if I was truly getting into sub-microsecond changes and logging multiple parallel signals, I would likely choose to use an FPGA anyways.</p>
</section>
<section id="microcontroller-block-diagram-and-schematic" class="level2">
<h2 class="anchored" data-anchor-id="microcontroller-block-diagram-and-schematic">Microcontroller Block Diagram and Schematic</h2>
<p>To implement an interrupt-based system on my MCU, I first had to choose how I planned to measure my system. Initially, I supposed that timing the difference between pulses might offer the best way to determine my motor’s speed. However, after this idea ended up producing significant error (up to 25%!), I instead pivoted to measuring the amount of pulses in a longer, fixed time. In order to measure direction, I stuck to the stage-based system which I previously discussed.</p>
<p>To turn this into code, I chose to create a main loop which contained a frame timer and my printing logic. This main loop was responsible for initiating and waiting for a half second timer, calculating revolutions per second (RPS), and printing to the user. In order to calculate RPS, I could create global variable logA and logB. Each time an edge came, I could increment the related logX variable. So, by manipulating the logX variable according to the equations in <a href="#fig-rps-calcs" class="quarto-xref">Figure&nbsp;2</a>, I could prepare them for the print statement. Speaking of, the print statement was relatively straightforward. By leaving the SEGGER debugger attached to the MCU via microUSB, we could print to it at our whim. I followed a tutorial created by Kavi Dey, found on a website of his <a href="https://kavidey.notion.site/Debugging-in-Segger-with-printf-114a56ecd5de8045a9ffe1b0a805db4d">here</a>. You can find out more about my implementation by looking at my <a href="https://github.com/jacksonphilion/e155_lab5">Github code</a>, in the source &gt; lib folder titled DEBUG.</p>
<div id="fig-rps-calcs" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-rps-calcs-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/rpsCalcs.jpeg" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-rps-calcs-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;2: Equations to yield final average Revolutions Per Second of motor
</figcaption>
</figure>
</div>
<p>Then, in order to track direction and actually log the pulses, I made use of interrupts. In the MCU, we can use logic contained within a GPIO pin block to monitor a signal, generating a unique interrupt for each A and B signal. By setting this interrupt to occur on each rising and falling edge and logging the respective logX variable, we can properly give the main function everything it needs to calculate the RPS. By tracking the state of the system at the beginning of each interrupt, then comparing it to see what direction the motor is traveling, we can thus determine direction and log that in a global variable visible to the main loop. A summary of this description may be found in the flowchart in <a href="#fig-flowchart" class="quarto-xref">Figure&nbsp;3</a> below.</p>
<div id="fig-flowchart" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-flowchart-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/flowchart.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-flowchart-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3: Flowchart describing main loop and interrupt code behavior
</figcaption>
</figure>
</div>
<p>Finally, attaching this system to our MCU is straightforward. We are given a 25GA-370 DC motor, with the datasheet our class references available <a href="https://hmc-e155.github.io/assets/lab/25GA370.pdf">here</a>. It requires a DC voltage supply between 0 and 12V, which I provided from a benchtop power supply (as seen in the system demo video above). I chose to attach the A encoder and B encoder signals to GPIO A and B ports respectively, making the code easy to parse. The simple schematic may be seen in <a href="#fig-schematic" class="quarto-xref">Figure&nbsp;5</a> below.</p>
<div id="fig-schematic" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-schematic-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/screenshot.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-schematic-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;4: Hardware schematic – note that VoltageSupply + and - refer to an external benchtop connection. DC Motor Used: <a href="https://hmc-e155.github.io/assets/lab/25GA370.pdf">25GA-370</a>
</figcaption>
</figure>
</div>
</section>
<section id="testing-the-system" class="level2">
<h2 class="anchored" data-anchor-id="testing-the-system">Testing the System</h2>
<p>As I tested version two of this system – which counts pulses within a 500 millisecond framing window, instead of timing between pulses – I noted a constant error. My output values seemed to be near 20% lower than my actual RPS. How do I know? I measured it, using a tool called a tachometer. This handheld tool, seen working in the <a href="https://youtube.com/watch/Shzgm0OBXzI">video linked here</a>, uses a laser and reflective tape to accurately calculate the RPM of a mechanical system. Using this, I was able to generate the table in <strong>?@fig-table</strong>, describing my MCU captured values against my Tachometer values.</p>
<div id="fig-schematic" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-schematic-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/table.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-schematic-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;5: Error table
</figcaption>
</figure>
</div>
<p>This table shows a consistent error, where my output value is between 21.1 and 22 percent lower than the actual value, assumed as equal to the tachometer. This consistent error is confusing to me. The first place I checked was my frame timer – if this was shorter than anticipated, then it would be under-reporting the true RPS. However, after counting a sequence of 60 cycles, I found that it was in fact under-reporting… by 1.06%. This is nearly within the error on the system clock itself, and certainly not significant enough to describe the consistent error. I then wondered if I could somehow be going too fast, and missing interrupts. However, the consistency of my error across voltages made me consider this a poor explanation. If this were the case, then I would have expected the error to grow with voltage as the system missed a larger and larger portion of the available pulses. Even now, I see no reason for this 22% error. It is not a simple factor of two error, nor could I imagine how it might come from my calculations. If only my B encoder counted at half the rate, then this could lead to a close ~25% drop. However, I checked both my A and B counters separately and they both had the same independent error. So, I do not know the source of this error.</p>
<p>However, I do know how to fix it. Since it is a constant error, applying a simple multiplication factor does the trick. However, I felt that it would be simplest to add this value in as an integer. To do so, I decided to add in a topFactor and botFactor integer to my code, effectively scaling my answer by <code>(topFactor/botFactor)</code>. The closest integers I could find under 1000 were <code>topFactor = 947</code> and <code>botFactor = 740</code>. Using these integer values introduces an error of &lt;0.05%. After implementing this scalar, my printed RPS values were extraordinarily spot on. As seen in <a href="#fig-tachometer" class="quarto-xref">Figure&nbsp;6</a>, I was able to measure in a velocity with an error below 1%, sometimes approaching nearly 0.1%. I am quite pleased with these results, even if I am unable to locate the mysterious 22% error.</p>
<div id="fig-tachometer" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-tachometer-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/tachometer.jpeg" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-tachometer-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;6: Tachometer and example, running at <em>617.5 Revolutions per Minute</em> (10.29 RPS)
</figcaption>
</figure>
</div>
<p><a href="https://youtube.com/watch/Shzgm0OBXzI">Watch the Tachometer video here</a>!! Youtube wouldn’t let me embed it here since I filmed vertically.</p>
<p>Finally, I want to mention that the system correctly reads out the direction, recognizing a clockwise, counterclockwise, and stopped motor.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/jacksonphilion\.github\.io\/hmc-e155-portfolio\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>