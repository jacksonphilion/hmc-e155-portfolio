[
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "E155 Blog",
    "section": "",
    "text": "Lab 2 Reflection\n\n\n\n\n\nA reflection on Lab 2 and why I made a wire octopus.\n\n\n\n\n\nSep 18, 2024\n\n\nJackson Philion\n\n\n\n\n\n\n\n\n\n\n\n\nLab 1 Reflection\n\n\n\n\n\nA brief reflection on Lab 1: Seven Segment Display\n\n\n\n\n\nSep 8, 2024\n\n\nJackson Philion\n\n\n\n\n\n\n\n\n\n\n\n\nMy Learning Goals\n\n\n\n\n\nA discussion of what I want to get out of E155: Microprocessors\n\n\n\n\n\nSep 2, 2024\n\n\nJackson Philion\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "Hello! My name is Jackson Philion. I’m a senior engineering student at Harvey Mudd College with a focus in Electrical Engineering. I have experience with Digital Design, MCU and FPGA programming in C and SystemVerilog, and love blending these aspects with work in Hardware Engineering.\nThis website contains a record of my work at Mudd in E155: Microprocessor-based Systems. Combining a STM32 MCU on the same board with a iCE40 FPGA, this class challenges students to build their electrical skills while ensuring they have the thorough documentation to back it up. Check out the Labs tab above to see more. Note that this website is under active development as the class proceeds throughout Fall 2024!\nAfter graduating from Concord Academy high school in 2020, I decided to take a gap year to explore my interests in Computer Science and Engineering. I began working with Cobra Puma Golf’s Innovation department to test and prototype new club heads and competitive technology, and finished working with Egghead Ventures on web development and new product prototyping. I returned to Egghead Ventures the following year, as well as taking on a role as a Head Counselor at my high school summer camp. I have since worked with Sol Clarity, a green energy start-up based in Boston, where I designed hardware and produced technical drawings for their upcoming field trial. After studying abroad in New Zealand with the University of Canterbury’s Electrical Engineering department, I look forward to launching a career which aligns with my varied interests. I hope to find the team which lets me design and implement digital circuits while making sure I have the hardware to back it up!\nCheck out the card links below to view my Github and Linkedin."
  },
  {
    "objectID": "posts/first-post.html",
    "href": "posts/first-post.html",
    "title": "My Learning Goals",
    "section": "",
    "text": "I remember being a freshman at Harvey Mudd College, living in the room directly across from where I live now as a Senior. I was an aspiring engineer, unsure of what exactly he wanted to actually… engineer. I loved solving problems, but I hadn’t yet figured out how I wanted to apply myself. I remembered talking to the engineering seniors in the singles across the hall – some worked on audio amplifiers and processors while others worked on drone tracking or materials research. I listened intently as people talked about their work. I asked a lot of questions, not about the technical details but about the day-to-day work. Around this time as a freshman, I identified my interest in Electrical Engineering. I loved my introductory Computer Science course, but I didn’t find it to feel as impactful or tactile as I had hoped. I loved physics, but similarly disliked the lack of immediate applications that I could dream for it. Electrical Engineering seemed to strike a perfect balance. Talking with the seniors, I heard about how they spent time working on their code, working on their hardware, and working in the field to apply their creation – it sounded like the perfect fit. I recalled my internship at Egghead with Tom Morris, where he tasked me with finalizing a plan for a cellular-enabled smart outlet. I remembered the excitement of rigging a power cable through my custom housing, connecting to the 3G network, and seeing the SMD LED first flash solid green. In this newly identified interest, I kept an ear out for courses that the successful electrical engineers at Mudd had all taken. E155: Microprocessors stood out as a clear winner."
  },
  {
    "objectID": "posts/first-post.html#intro-engineer-of",
    "href": "posts/first-post.html#intro-engineer-of",
    "title": "My Learning Goals",
    "section": "",
    "text": "I remember being a freshman at Harvey Mudd College, living in the room directly across from where I live now as a Senior. I was an aspiring engineer, unsure of what exactly he wanted to actually… engineer. I loved solving problems, but I hadn’t yet figured out how I wanted to apply myself. I remembered talking to the engineering seniors in the singles across the hall – some worked on audio amplifiers and processors while others worked on drone tracking or materials research. I listened intently as people talked about their work. I asked a lot of questions, not about the technical details but about the day-to-day work. Around this time as a freshman, I identified my interest in Electrical Engineering. I loved my introductory Computer Science course, but I didn’t find it to feel as impactful or tactile as I had hoped. I loved physics, but similarly disliked the lack of immediate applications that I could dream for it. Electrical Engineering seemed to strike a perfect balance. Talking with the seniors, I heard about how they spent time working on their code, working on their hardware, and working in the field to apply their creation – it sounded like the perfect fit. I recalled my internship at Egghead with Tom Morris, where he tasked me with finalizing a plan for a cellular-enabled smart outlet. I remembered the excitement of rigging a power cable through my custom housing, connecting to the 3G network, and seeing the SMD LED first flash solid green. In this newly identified interest, I kept an ear out for courses that the successful electrical engineers at Mudd had all taken. E155: Microprocessors stood out as a clear winner."
  },
  {
    "objectID": "posts/first-post.html#what-i-want-to-walk-away-with",
    "href": "posts/first-post.html#what-i-want-to-walk-away-with",
    "title": "My Learning Goals",
    "section": "What I Want to Walk Away With",
    "text": "What I Want to Walk Away With\nAs I approach this course, I recognize it as a capstone of sorts. While I will pursue other electrical courses while at Mudd, perhaps none will provide a greater boost to my electrical expertise. Further, I plan to directly apply these skills as I pursue my sponsored work with HRL Labs for FPGA in quantum computing control systems. So, I want this class to ultimately help me develop into an electrical engineer who is ready to start a career development program in a professional setting. With that said, I hope to:\n1. Gain an understanding of FPGAs and their applications.\nAs I hope to develop confidence in my career as an electrical engineer, and understanding of FPGAs seems critical. They are a basic building block of everything from simple embedded systems to high-speed computing at the cutting edge of finance. I want to be capable of sustaining technical conversations with employers and coworkers where I can understand how to apply FPGAs. This means understanding how to break a task into a block diagram, understanding the software and Verilog necessary to implement the task, and most importantly – recognizing the gaps in my knowledge that I need to fill in order to manifest my solution.\n2. Increase my Autonomy (by failing more often).\nAn important part of being a team member is understanding when to seek collaboration and when to strike forward for the sake of progress. Increased collaboration may lead to more “correct” results more often, but a dependency on collaboration hinders both your own growth and the efficient progress of the project. Conversely, one might imagine that you can steep-track project progress by focusing on indivual progress. However, this may cause one to lose sight of the project’s overall goals and render contributions meaningless. I find that I more often tend to strive for a perfect solution, meaning that I end up checking in often with coworkers to make sure that I am on “the right track”. I think I would benefit from increasing my autonomy. In order to do this, I have to be willing to try things and fail more often in smaller pieces. I have to be willing to go out on a (safe) limb and experiment, then bring my results to the group. I believe that this will lead to personal growth, making me a better player on my future team."
  },
  {
    "objectID": "posts/first-post.html#final-thoughts",
    "href": "posts/first-post.html#final-thoughts",
    "title": "My Learning Goals",
    "section": "Final Thoughts",
    "text": "Final Thoughts\nWhile I reserve the right to learn more, these are the essential points that I would be disappointed to leave this class without. These are the points that I think will help me kickstart my career in electrical engineering. I thank Harvey Mudd for putting forth the challenge of this class to its students – I have been excited to take it head on since I was a freshman. I believe that challenges like these are what will push me from student to practicioner, and I can’t wait to see the transition take shape. Lab One is already proving to be deceptively simple though not at all easy. So, here we go – Off to the races!"
  },
  {
    "objectID": "labs/lab4/lab4.html",
    "href": "labs/lab4/lab4.html",
    "title": "Lab 4",
    "section": "",
    "text": "Placeholder Text"
  },
  {
    "objectID": "labs/lab4/lab4.html#lab-4-digital-audio",
    "href": "labs/lab4/lab4.html#lab-4-digital-audio",
    "title": "Lab 4",
    "section": "",
    "text": "Placeholder Text"
  },
  {
    "objectID": "labs/lab2/lab2.html",
    "href": "labs/lab2/lab2.html",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "",
    "text": "Quick Stats\nTime Spent: 21 Hours, 35 Minutes, 14 Seconds\nMisunderstood Ideas: 1\nResulting Unnecessary 3D Prints: 1\nResulting Unnecessary Wiring Harnesses: 2\nTestbench: Automatic\nDual Display: Steady, Discrete, and Illuminated\nOverall: Success\nSee my Blog Reflection for more! Dare I say, it contains a particular treat this week."
  },
  {
    "objectID": "labs/lab2/lab2.html#lab-task-double-the-display",
    "href": "labs/lab2/lab2.html#lab-task-double-the-display",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Lab Task: Double the Display",
    "text": "Lab Task: Double the Display\nFor the unfamiliar, Lab 1 asked students to read in a set of 4 switches, representing a hex number from h0 - hF. Lab 1 already set up the system to display this number using a single seven-segment display and a set of onboard LEDs.\nLab 2 asks students to build on this system by adding a second set of switches which control a second seven-segment display, and to use LEDs to instead display the sum of the two 4-bit switch inputs as a 5-bit number. Here’s the catch – the lab challenges students to accomplish this doubling in display capacity without instantiating a second module in SystemVerilog, and without using a second set of FPGA pins. In other words, students were tasked with doubling the display outputs without doubling the hardware."
  },
  {
    "objectID": "labs/lab2/lab2.html#enter-time-multiplexing",
    "href": "labs/lab2/lab2.html#enter-time-multiplexing",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Enter: Time Multiplexing",
    "text": "Enter: Time Multiplexing\nWe can use time multiplexing to accomplish our double display task. Time multiplexing gives designers a way to utilize common hardware for different inputs and outputs. For example, in a high speed processor, having a unique data line going between every part inside would waste space and be expensive. Instead, designers create a shared pathway, letting different units use it to communicate at different times. I think of it like a landline in a time before cell phones – not every member of the family needs their own. You can install one for the whole house, then schedule a time for each family member to make their calls. Voila, you have time multiplexed your house! Take a look at Figure 2 below. Here, you see a block diagram illustrating the idea, as well as a timing diagram describing how one might lay out the signals in time.\n\n\n\n\n\n\nFigure 2: Time multiplexing block diagram and signal timeline\n\n\n\nIn this case, we have two sets of input switches which want to use the same limited FPGA pins to illuminate their displays. Luckily for us, the human eye isn’t too great at detecting flicker. The United States National Institute of Medicine reports that humans cannot distinguish between flashes of light if the time separating them is less than 10 milliseconds, or over 100 Hz – they will just see a solid glow. On the other hand, our FPGA has an internal oscillator capable of running at 48 MHz, nearly a half million times faster than our eye can detect. So, if we simply use the same set of pins to control either display, turning one on and then the other in sequence, we can easily create the illusion of two simultaneously powered displays while using the same hardware to control them. In my case, I chose a frequency of 500 Hz to be extra safe."
  },
  {
    "objectID": "labs/lab2/lab2.html#hardware-understanding-and-setup",
    "href": "labs/lab2/lab2.html#hardware-understanding-and-setup",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Hardware – Understanding and Setup",
    "text": "Hardware – Understanding and Setup\nThe hardware for this lab required a few special considerations. First off, we used a different seven segment display. It still had a common anode schematic, but I instead used a dual display with the following pin mappings as seen in Figure 3 below:\n\n\n\n\n\n\nFigure 3: Dual seven segment display pin mappings\n\n\n\nI was able to use the same calculations from Lab 1 to show that a load resistor of 240 Ohms is sufficient to limit the current to under 10 mA for each segment – recall the maximum is 30 mA. Now, note in the figure above that there is a common anode for each side of the display. That is to say, two connections to power should be made in order to illuminate each half. This is where I may apply a time multiplexing scheme. I can control which display gets powered at any time, making sure that I ground the other anode, in order to effectively switch between the two displays. By doing this at my chosen 500 Hz frequency, the human eye will interpret both displays as solidly on. Then I can run the same seg[6:0] signal to the display pins on both sides. By switching the digit I send down these shared segment pins, and lining these changes up with the L and R power signal, I can effectively control two displays at once with the same 7 lines of segment hardware (plus two power control signals).\nHowever, I now need to configure the common anodes to be controlled low or high via my FPGA pins. One might ask – couldn’t you just use the FPGA pin directly to control the voltage level? The answer is no – the segment draws an unsafe amount of current, too high to be routed directly though the FPGA pins. Specifically, this datasheet about our iCE40 FPGA chip indicates that at 3.3V logic, the maximum I/O current is 8mA. Given that I draw just under this with a single segment, I cannot use it to control the common anodes. Instead, I may use a PNP transistor switch. The simple circuit and calculations which describe its behavior may be found below in Figure 4. In summary, a base resistor of 470 Ohms allows our FPGA pin to control a single point, Vin, to enable to disable each pin. In this process, the maximum current allowed in the transistor pin is limited to 5.5mA, an acceptable maximum. Also note that my diodes should be pulling between 5 and 8 mA, similarly under the FPGA pin current limit, per my Lab 1 calculations.\n\n\n\n\n\n\nFigure 4: Transistor circuit and current calculations\n\n\n\nHowever confident I was with this design, I wasn’t sure how it would interact with a varying load. Recall that each number displayed illuminates a unique sequence of LED segments. Displaying a 1 requires illuminating 2 segments, while displaying an 8 requires illuminating all 7. I wasn’t sure how this varying load would affect the current though the FPGA pin and LED segments, even if I was relatively confident that I had designed my system to operate at the maximums. So, I turned to Flastad, an online circuit simulation tool, to help me understand how my circuit would respond to different illumination regimes. The following Figure 5, Figure 6, and Figure 7 show the three different operational minimums and maximums of the circuit – illumination off, illumination on with a minimum display load, and illumination on with a maximum display load. In each case, we see that the current through each LED segment into the FPGA pins, as well as the base current, is well within specificaiton.\n\n\n\n\n\n\nFigure 5: Falstad Simulation: PNP switch off\n\n\n\n\n\n\n\n\n\nFigure 6: Falstad Simulation: PNP switch on, minimum LED load\n\n\n\n\n\n\n\n\n\nFigure 7: Falstad Simulation: PNP switch on, maximum LED load\n\n\n\nFinally, I considered how I would chose to display the 5 LEDs which represented the sum of both 4-bit switch groups. I decided that I could use the 3 blue LEDs onboard the E155 development board, the same as those used for Lab 1, while also using the two green LEDs above. These could be connected to the FPGA using the fourth and eighth switch on the board’s SW7 8-pole DIP switch.\nWith my connections determined, I created a breadboard circuit according to the following schematic in Figure 8 and proceeded to design my software. Note that the schematic may also be found in PDF form on my Lab 2 github here, under notes and extras.\n\n\n\n\n\n\nFigure 8: Schematic"
  },
  {
    "objectID": "labs/lab2/lab2.html#software-block-diagram-systemverilog",
    "href": "labs/lab2/lab2.html#software-block-diagram-systemverilog",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Software – Block Diagram & SystemVerilog",
    "text": "Software – Block Diagram & SystemVerilog\nHaving designed the hardware, I proceeded to plan out my software implementation. I first created a block diagram to describe my system, as found in Figure 9 below. Note that I included a sort of Finite State Machine, or FSM. Well, a quasi-FSM. At the very least, something that is best described by a Moore FSM diagram. In this case, I wanted to switch between two states, displayL and displayR, at a chosen frequency “toggleFreq”. Since I want the display to flash at 500 Hz, I set the toggleFreq to 1000 Hz since the switching nature of the FSM effectively halves the toggleFreq. This diagram, in Figure 10, describes the Toggle FSM block in Figure 9.\n\n\n\n\n\n\nFigure 9: Block diagram\n\n\n\n\n\n\n\n\n\nFigure 10: Rudimentary FSM diagram to explain display switching behavior\n\n\n\nWith this understanding laid out, I proceeded to write my SystemVerilog code. This may be found in the FPGA folder on my Lab 2 github here. Aside from some debugging trying to pass parameters to my frequency generation module, it was relatively smooth sailing."
  },
  {
    "objectID": "labs/lab2/lab2.html#simulation",
    "href": "labs/lab2/lab2.html#simulation",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Simulation",
    "text": "Simulation\nFor this lab, I was easily and effectively able to write a testbench to demonstrate that my LED logic. The testbench code may be found on my Lab 2 Github, and the waveform and successful run message may be seen in Figure 11 below.\n\n\n\n\n\n\nFigure 11: LED testbench success – note the message, 0 errors across 8 tests\n\n\n\nRecall that lab 1 already demonstrated (by automated testbench) the successful functioning of the seven segment logic module. Similarly, I have demonstrated that my frequency generator module is effective, and I continue to use/reuse it in this lab with a different frequency parameter.\nThe tricky module to thoroughly test in an automated bench is the displayMultiplexer module. For this, I decided to use a hybrid manual/automatic testbench. I removed the internal oscillator and frequency generator from the module, and instead passed in my own toggleFreq line. I chose to simulate this signal at a rather rapid pace, letting me easily see whether the display was switching or not in simulation. The automatic part of the testbench involved using a .tv file to load in my switch inputs and to generate waveforms of my expected illuminated outputs. The manual part of the testbench involved checking the results. I basically ran the toggle signal out of sync with the testbench’s internal clock, meaning that I wouldn’t be sure what to read out, when. Instead of finagling the two signals to sync up, I decided that manually checking was both easier and more effective. Figure 12 shows my view of the whole simulated testbench, including the 4 test points. For these test points, I chose to display 00, 06, C9, and F3. I figured that if these all displayed the right segments, and the display signal toggled as expected, then I could demonstrate the module was working. Figure 13 shows a close up example of one of my test points, as well as some marked analysis that demonstrated my thinking.\n\n\n\n\n\n\nFigure 12: Full display testbench waveform\n\n\n\n\n\n\n\n\n\nFigure 13: Annotated close up of one test point from the display testbench\n\n\n\nNote that these images may be found also in the extras folder of this lab’s Github here. In any case – all signals generated as expected! Testbench success for all modules!"
  },
  {
    "objectID": "labs/lab2/lab2.html#final-system",
    "href": "labs/lab2/lab2.html#final-system",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Final System",
    "text": "Final System\nAfter assembling the final pieces together and running the programmer, the system worked as expected. The display itself was a touch dimmer than I may have liked – I think part of the problem was the color I chose. I could have boosted the current values to get a brighter display, but as Figure 4 showed, I had already thought carefully about my tolerated currents and did not wish to push my luck. Thus, I yield my full system, shown in Figure 14.\n\n\n\n\n\n\nFigure 14: Complete system\n\n\n\nA final reminder that full images, source code, and more can be found in this lab’s Github here. In addition, to learn more about the mysterious “Misunderstood Idea” and “Unnecessary” 3D prints and wire harnesses that I mentioned in the top stats, check out my blog post for this week! So much work gone to… well, not waste, but… to the blog post! Until next week."
  },
  {
    "objectID": "labs/lab7/lab7.html",
    "href": "labs/lab7/lab7.html",
    "title": "Lab 7",
    "section": "",
    "text": "Placeholder Text"
  },
  {
    "objectID": "labs/lab7/lab7.html#lab-7-the-advanced-encryption-standard",
    "href": "labs/lab7/lab7.html#lab-7-the-advanced-encryption-standard",
    "title": "Lab 7",
    "section": "",
    "text": "Placeholder Text"
  },
  {
    "objectID": "labs/lab1/lab1.html",
    "href": "labs/lab1/lab1.html",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "Quick Stats\nTime Spent: 18 Hours\nSystemVerilog Modules Written: 4\nSoftware Installs/Tutorials: 4\nTestbench: Eventual Success\nOverall: Success\nSee my Blog Reflection for more!"
  },
  {
    "objectID": "labs/lab1/lab1.html#prelab-skills",
    "href": "labs/lab1/lab1.html#prelab-skills",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Prelab Skills",
    "text": "Prelab Skills\nLab 1 introduces students to some foundational elements of the class before asking them to do their first piece of generative design work. Chiefly, it introduces students to three key softwares that will be essential to success throughout the rest of the class:\n\nThe FPGA design software Radiant Lattice, which is used for implementing designs onto the FPGA and mapping pin ins and outs. This is new to most students.\nThe MCU design system SEGGER Embedded Studio, which most students have experience with but have not yet connected to an ARM processor.\nGit and Github tools, which is a required organizational tool in this class due to its importance throughout personal and professional work in coding and electrical engineering.\nQuarto website builder, a software system added as an extension to VSCode which has allowed me to build up this portfolio.\n\nFor all intents and purposes, I was a complete beginner with all three of these tools. Thus, the majority of my work in Lab 1 was spent combing through posted class tutorials, checking with online walkthroughs, and building shorthand cheat sheets to help contain the rush of new information. The good news? I now feel comfortable building a raw .sv file from scratch and using Radiant Lattice and Modelsim to integrate and push it to the FPGA. I also feel more confident than I should about building out a test bench – I have yet to integrate an automated one successfully, but I can imagine what I will change for my next iteration in lab 2. It successfully compiled but failed to pull in my testvector.tv file. I realize now that it was in fact a hidden testvector.tv.txt file – Windows has to stop hiding extensions! I also have numerous working testbenches to pull from in my E85 digital electronics work, and thoroughly enjoyed the satisfaction back then of writing a thorough test bench! All that is to say, I am excited to refine my testbench next week and feel confident that I have a route forward. This lab did not involve SEGGER to any significant degree, so I will hold off discussion of that software until a future week.\nI have also built a basic level of fluency with git – I’m happy to report that the cheatsheats barely get any use! Initializing, adding, branching, committing, pushing and pulling are second nature at this point. This was due partially to a hugh warm up period in which I accidentally created 4 different repositories for Lab 1. Combing through this mess to understand what happened and how to fix it contributed significantly to my learning. I still have to look up some commands for finding the correct remote address, and sometimes find myself using the GitHub desktop app for some arranging. However, I mostly use the bash command terminal, and have gotten comfortable interfacing with the lab computers to continue coding projects across any desktop I choose. I still need to build significant fluency with merging and managing branches after creation. I can walk through the steps, but I am left uncomfortable with more than one branch left open at a time and often delete branches immediately after their creation. I think I have yet to fully understand how branches will be a benefit to my work.\nQuarto is also a work in progress. Consider the design of this page my first real world test of this skill – did I succeed? How can I improve? This is what I will ask myself in preparation for my lab 2 page next week."
  },
  {
    "objectID": "labs/lab1/lab1.html#lab-task-seven-segment-display",
    "href": "labs/lab1/lab1.html#lab-task-seven-segment-display",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Lab Task: Seven Segment Display",
    "text": "Lab Task: Seven Segment Display\nAfter the preliminary skills introduction, the primary task of Lab 1 is rather simple.\nThe task:\n\nTake as an input 4 switches, set in order to each represent a consequitve input bit.\nControl a seven segment display to read out the 16 hexidecimal digits from 0 to 15 (or h0 to hF), which correspond to the 4 bit input.\nIn addition, control 3 onboard LEDs to obey the following truth tables with relation to the switch inputs:\n\n\nTable 1: led[0] Truth Table\n\n\nS1\nS0\nled[0]\n\n\n\n\n0\n0\nOFF\n\n\n0\n1\nON\n\n\n1\n0\nON\n\n\n1\n1\nOFF\n\n\n\n\n\n\nTable 2: led[1] Truth Table\n\n\nS3\nS2\nled[1]\n\n\n\n\n0\n0\nOFF\n\n\n0\n1\nOFF\n\n\n1\n0\nOFF\n\n\n1\n1\nON\n\n\n\n\n\n\nTable 3: led[2] Truth Table\n\n\nled[2]\n\n\n\n\nBlink at 2.4 Hz\n\n\n\n\n\nWith the task laid out, and my skills adequately built up, I tackled the lab by first attempting to understand the seven segment display."
  },
  {
    "objectID": "labs/lab1/lab1.html#understanding-the-display-inputs-and-outputs",
    "href": "labs/lab1/lab1.html#understanding-the-display-inputs-and-outputs",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Understanding the Display, Inputs, and Outputs",
    "text": "Understanding the Display, Inputs, and Outputs\nI began my task by trying to understand the seven segment display. This would give me an idea of how many signals I needed to run to it, and how to map out a truth table which would describe each hex number. My selected display unit had a clearly printed serial number on it, which corresponded to the following Jameco Link and the following data sheet. Based on these resources, I derived that I could control the segments of my display via the following pin mapping:\n\n\n\n\n\n\nFigure 2: Seven segment display pin mapping\n\n\n\nNote that this component uses a Common Anode, attached to the manufacturer’s pin 3 and pin 8 of the display. That is to say, by connecting my high voltage rail (in this case 3.3V) to either pin 3 or 8, it would supply the positive anode for every segment. The pins then could be controlled at logic high, leaving the segment off with 0V across it, or logic low, to supply the voltage differential which draws current through the segment and illuminates it. However, the forward voltage of these segment diodes is listed at 2.1V with a maximum forward current of 30 mA [see Jameco Datasheet]. Thus, in order to limit the current, as well as to bridge the remaining 1.2V gap between the positive rail and ground, a resistor needs to be added in series with the segment. In order to reduce the current load on my chip, I chose to operate the segments at a relatively low 5mA of forward current. Using this 1.2V gap and 5mA desired current, I was able to calculate a desired resistor value of 240 Ohms. Figure 3 below elucidates this point by supplying additional calculations and equations.\n\n\n\n\n\n\nFigure 3: Current calculations for seven segment display\n\n\n\nI chose to wire a resistor up to each segment in order to illuminate the segments equally brightly. If I chose to wire two segments up with the same resistor to ground, there would be no issue – the calculations might change, but with an operating current range between 5 and 30 mA, there is plenty of room to drive multiple segments with the same resistor. However, this would cause inequalities in current across the segments of the display, causing inequalities in illumination intensity. To maintain the same visible level of illumination, I thus opted to use a resistor for each segment I chose to illuminate. You can look ahead at the schematic I use down in Figure 6.\nI finally had to decide how I wanted to illuminate the display to represent each digit. I first drew a design of each character as it would appear on the display, as seen in the upper portion of Figure 3 below. Understanding that I would need 7 lines of input to control the desired segments, I was able to determine that I needed an output signal of seg[6:0]. Using the digit design and these seg outputs, I then derived the truth table in the lower portion of Figure 4. This truth table allows me to describe exactly which signals need to be illuminated to represent each digit. Note a blank square is an implied 0, or “seg[i] off.”\n\n\n\n\n\n\nFigure 4: Digit design and truth table\n\n\n\nFinally, there is the matter of the 3 onboard leds which should map to the oscillator and input switches. However, both led0 and led1 may be represented by simple “xor” and “and” operations in the FPGA, respectively. The final led2 output was dictated by an oscillator which similarly might be represented by an operation on the FPGA. None of the led signals required any external hardware that was not already onboard the E155 development board. Thus, I did not consider these outputs until I did my design in SystemVerilog.\nWhich is a perfect segue into the next section! Having understood the functionality of the display, the circuitry I needed to construct around it, and the truth table I wanted to implement, I finally had to consider how I would use the FPGA to generate my seg[6:0] and led[2:0] signal outputs using SystemVerilog language."
  },
  {
    "objectID": "labs/lab1/lab1.html#system-design",
    "href": "labs/lab1/lab1.html#system-design",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "System Design",
    "text": "System Design\nI had most fun in this lab with the system design in SystemVerilog. It was always one of my favorite pieces of E85 Digital Electronics, and this held true for this first lab of E155. Figure 5 below describes the abstract view of inputs and outputs that my SystemVerilog modules are based upon.\n\n\n\n\n\n\nFigure 5: SystemVerilog Block Diagram\n\n\n\nUsing this diagram, I began to build out my code in SystemVerilog. You can find my .sv code files at in by Lab 1 github repository here.\nAdditionally, you can find the final schematic in Figure 6 below. Note that I hooked up my breadboard pins first at my convenience, then went back after the fact and used Lattice Radiant to assign the pin outputs. This schematic also shows how I hooked the seven segment display up with the common anode and separate resistor for each segment.\n\n\n\n\n\n\nFigure 6: Schematic and pin mappings"
  },
  {
    "objectID": "labs/lab1/lab1.html#simulation",
    "href": "labs/lab1/lab1.html#simulation",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Simulation",
    "text": "Simulation\nAfter writing my code, I endeavored to simulate its proper function using ModelSim. Note that I would have wanted to use the Questa simulator built into Lattice Radiant, but licensing issues left me using the good old desktop app instead. I first ran a series of forces to set my inputs and verified that each output read as intended. The results of this may be seen in Figure 7 below. Note that the raw image may be viewed, along with the source code, at my Github here.\n\n\n\n\n\n\nFigure 7: Forced simulation demonstrating proper inputs and outputs\n\n\n\nHowever, I wanted to stretch myself to write an automatic testbench instead. I believe that this skill will be instrumental for my SystemVerilog going forward, and I wanted to dust off my testbench-writing-chops right away. After many attempts (and finally removing the .txt extension from my .tv file), I was successful! It does not yet run automatically, needing instead to be fed the command “run 163” after simulation start. Yet, the test bench displays zero errors across each test case (which was all of them). It loads and evaluates each test vector from the .tv file. I am incredibly pleased, and aim to jump off of this first test bench in order to write my next one for lab 2. The successful run results may be seen in Figure 8 below, yet again, the raw image may be found on my github here.\n\n\n\n\n\n\nFigure 8: Testbench simulation demonstrating proper ins and outs, loading of test vectors, and zero errors"
  },
  {
    "objectID": "labs/lab1/lab1.html#completed-system",
    "href": "labs/lab1/lab1.html#completed-system",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Completed System",
    "text": "Completed System\nFinally, with a system designed and tested, I prepared to upload it to my FPGA. I ran into multiple errors on one particular lab computer with programming. While the computer could detect the FPGA and the linking cable, the connection would fail when trying to run the final step. However, after switching to a new computer which a friend had used successfully, I was able to download the code to my system and demonstrate its success! The LED system worked as intended. I did not carefully clock the frequency of led[2], intended to be 2.4Hz. It was certainly doing between 2-3 cycles per second, so I assumed that it was working as intended. However, next time, testing this more thoroughly may reveal further issues for investigation – hard to say without nailing down a measured frequency. However, back to the success! Below you can find Figure 9 with the full system shown, as well as Figure 10 demonstrating that the seven segment display responds as intended with equally bright segments.\n\n\n\n\n\n\nFigure 9: The completed system\n\n\n\n\n\n\n\n\n\nFigure 10: Demonstration of each digit illuminated correctly in final design\n\n\n\nThus concludes my interactions with Lab 1. You can find a reflection of this weeks work in the blog postings, or can head on over to Lab 2 and see what’s next! Spoiler alert: We’re going to try and double the amount of displays without doubling the GPIO burden."
  },
  {
    "objectID": "labs/lab6/lab6.html",
    "href": "labs/lab6/lab6.html",
    "title": "Lab 6",
    "section": "",
    "text": "Placeholder Text"
  },
  {
    "objectID": "labs/lab6/lab6.html#lab-6-the-internet-of-things-and-serial-peripheral-interface",
    "href": "labs/lab6/lab6.html#lab-6-the-internet-of-things-and-serial-peripheral-interface",
    "title": "Lab 6",
    "section": "",
    "text": "Placeholder Text"
  },
  {
    "objectID": "labs/lab5/lab5.html",
    "href": "labs/lab5/lab5.html",
    "title": "Lab 5",
    "section": "",
    "text": "Placeholder Text"
  },
  {
    "objectID": "labs/lab5/lab5.html#lab-5-interrupts",
    "href": "labs/lab5/lab5.html#lab-5-interrupts",
    "title": "Lab 5",
    "section": "",
    "text": "Placeholder Text"
  },
  {
    "objectID": "labs/lab3/lab3.html",
    "href": "labs/lab3/lab3.html",
    "title": "Lab 3",
    "section": "",
    "text": "Placeholder Text"
  },
  {
    "objectID": "labs/lab3/lab3.html#lab-3-keypad-scanner",
    "href": "labs/lab3/lab3.html#lab-3-keypad-scanner",
    "title": "Lab 3",
    "section": "",
    "text": "Placeholder Text"
  },
  {
    "objectID": "posts/lab1-post.html",
    "href": "posts/lab1-post.html",
    "title": "Lab 1 Reflection",
    "section": "",
    "text": "As I write this reflection, I am still riding the high of making 2 major adjustments to my Lab 1 source code – with nary an error along the way. It’s an incredible feeling. However, don’t get me wrong – I still failed. A lot. Like, way more than I usually do. But, that failure was intentional. It was a stated part of my learning goals, and I can tell it’s already paying dividends.\nReferring back to my first post on learning goals, I only listed a brief two. I felt that these most effectively summarized the litany of knowledge and skills which I hoped to gain from this course.\n\nGain an understanding of FPGAs and their applications; and\nIncrease my Autonomy (by failing more often).\n\nLab 1 did indeed give me my first introduction to FPGAs. I understand them now as powerful tools which may be simply harnessed using SystemVerilog and Lattice Radiant. That is to say, I understand how one can put most any desired hardware into SystemVerilog language, program it onto an FPGA, then connect that virtual hardware to the outside world through simple pin assignments. The limit is only drawn by your FPGA’s… capacity? Size? Configuration? I’m still sorting out the specific details, but my point stands – I recognize FPGAs for the effective tools they are, and can’t wait to jump into Lab 2 with this knowledge next week.\nHowever, I want to focus this reflection on my second learning goal, as I think it has seen the most impact thus far. Do you recall me saying that I failed a lot? Well, I meant it. I went into the MicroPs lab 6/7 days of the week to get this lab done to my expectation, and spent 18 hours working on it outside of class. Where did this time go? So little of it went towards what I traditionally consider “succeeding.”\nConsider a hallmark of Jackson Philion’s workflow – the first draft gets submitted. I agonize over each sentence, demanding near-perfection from every line, but make no mistake – once the final sentence has been written, I do not read it again. These 6 days in the lab did not follow this usual workflow. I revisited the same chunks of code over multiple days, making revisions on already-functioning pieces to polish up the result. Nor did these days meet my traditional standard for success, as I went home on more than half of them knowing that I would see the same error messages tomorrow. Two years ago, I would have been infuriated with these “failings” and “inefficiencies”. A year ago, heck even a couple months ago, I would have gone on hours-long lab binges until I could leave with a sense of success. Now, don’t get me wrong, I still had one lab binge… after all, we’re all just works in progress, right? However, as I sit here still riding the high of my relatively error-free night, I feel success in those days that I failed. I think back, and I realize that I never felt that sense of impending doom called failure. I looked forward to taking my next crack at it tomorrow, during my planned lab time. While I worked alongside friends, I didn’t lean on them to help me resolve my errors to the usual extent. I made an intentional effort to let myself try and fail at least 3 times. Most often, this resulted in a new piece of learning that may not have been conveyed otherwise. Instead of feeling like agony, these moments were more jovial than I expected.\nI think I am reveling in the challenge that this class represents. As I have mentioned before, I have been hearing about this class and building up to it since I was a freshman. I think I have bought into some vision that this is the class which is meant to forge oneself into a high-performing professional. In this mindset, it is easy for me to embrace new workflows, new schedules, and new failures. It’s easy to start week one of the course and give it my all, and it’s easy to see the success and learning that failing autonomously has brought me. After 18 hours spent combing through documentation and forums, I am proud to say that my most recent edits had no errors because I had already gotten them all. Not because I was perfect, but because I failed and revised enough to find the right path. And right now, it feels great.\nLooking forward, I am considering what next week will bring. To make a crude analogy, I feel like I am feasting on ham after winning the war’s first summertime battle. I fought, I struggled, and I won. I was surrounded by my A-team… tutorials, quick-start guides, and similar week-one aids. I didn’t have other classes yet vying for my attention. In short: I was surrounded by things that made it easy to fail and get right back up again. However, this is a semester-long class, not a summer workshop. I need to win the war, not just the battle. I need to win the battle in the dead winter when supplies have been low for weeks. Sure, I’m on the right track now, but will I still be when my first Politics essay is due? When technical work with HRL Labs Clinic begins in earnest? When I come back from Thanksgiving break and have to motivate through Finals? I think I need to spend some time preparing for that eventuality, rather than letting it get the best of me.\nThat is to say, this week I am feeling great. I am thoroughly excited to pursue the rest of this coursework, and to try out new things: failing, reflecting in these posts, writing up my work thoroughly, partitioning the workload like a job. But I’m nervous to see how I respond when failing starts to feel… not good. That will be the true test of my learning goals. I can’t tell whether I actually want that point to come or not. For now, I guess we’ll remain in suspense until next week. September 8, 2024."
  },
  {
    "objectID": "posts/lab2-post.html",
    "href": "posts/lab2-post.html",
    "title": "Lab 2 Reflection",
    "section": "",
    "text": "If I recall my reflection from Lab 1 correctly, its main refrain was: “This week was nice, and I learned a lot, but I’m scared for when things get not-so-nice”. Well, this week certainly toed that line, introducing some highs and lows that tested my resolve just a bit.\nAnd to think… the week started so well…\nWhen I first began Lab 2, I was (and this is the best word here) stoked. I was excited for a relatively easy lab that reused a lot of code from last week, taught me a new concept (time multiplexing), and had something cool to show for it. Thats why I got so excited when I saw the specification for Excellence, reading: “Digits on the seven-segment display are upright to the viewer.” At first, I wasn’t sure what to make of this specification. Prof Brake didn’t mean that the digits had to be literally upright – did he? If that was the case, I wondered… well, couldn’t you just tilt the breadboard up to face out towards a room? Surely that can’t be what he means.\nThen I asked a class TA and sure enough, he meant just that. I had to get my digits to stand physically upright."
  },
  {
    "objectID": "posts/lab2-post.html#intro",
    "href": "posts/lab2-post.html#intro",
    "title": "Lab 2 Reflection",
    "section": "",
    "text": "If I recall my reflection from Lab 1 correctly, its main refrain was: “This week was nice, and I learned a lot, but I’m scared for when things get not-so-nice”. Well, this week certainly toed that line, introducing some highs and lows that tested my resolve just a bit.\nAnd to think… the week started so well…\nWhen I first began Lab 2, I was (and this is the best word here) stoked. I was excited for a relatively easy lab that reused a lot of code from last week, taught me a new concept (time multiplexing), and had something cool to show for it. Thats why I got so excited when I saw the specification for Excellence, reading: “Digits on the seven-segment display are upright to the viewer.” At first, I wasn’t sure what to make of this specification. Prof Brake didn’t mean that the digits had to be literally upright – did he? If that was the case, I wondered… well, couldn’t you just tilt the breadboard up to face out towards a room? Surely that can’t be what he means.\nThen I asked a class TA and sure enough, he meant just that. I had to get my digits to stand physically upright."
  },
  {
    "objectID": "posts/lab2-post.html#creating-a-housing-for-uprightness",
    "href": "posts/lab2-post.html#creating-a-housing-for-uprightness",
    "title": "Lab 2 Reflection",
    "section": "Creating a Housing for “Uprightness”",
    "text": "Creating a Housing for “Uprightness”\nThe more I thought about it, the more it represented an interesting challenge. Say you wanted to leave your breadboard flat on the table and read out the digits “upright to the viewer”. One would have to create some sort of contraption to hold the display in place in this upright position. Then, how would one get the electrical contacts to the LED display? A custom wiring harness would do it. As I peeked ahead at Lab 3, I saw that we will use the same hardware again… Wouldn’t that be something cool to bring forward? A standalone LED display with a custom wiring harness that connected up to my development board?\nWith this idea in mind, and the hope that I had time to spare this week, I got straight to work on my hardware schematic and standalone display setup. I figured that I would need to design the hardware from the ground up in order to accommodate this detachable display. I cracked open my favorite CAD software (Onshape), grabbed a pair of calipers, and modelled up this little guy below.\n\nAfter brushing up on my college’s 3D printing quizzes to gain access, I discovered that their suite of brand new machines would serve me incredibly well. Using an extra fine layer height (this is for presentation after all) I printed this result below. \nAfter checking the fit, I found it was perfect!\n\nI planned to loop back around later to make a stand for the housed display. That’s why the display housing has tabs to the right and left – a sturdier display with a hollow core could have rested flat on the desk and routed the wiring down through the display housing and out the back of the stand. I figured that I had a couple more steps to go before I got there though! While I was developing my code and block diagram in parallel, I started work on a wiring harness."
  },
  {
    "objectID": "posts/lab2-post.html#wiring-harness-1",
    "href": "posts/lab2-post.html#wiring-harness-1",
    "title": "Lab 2 Reflection",
    "section": "Wiring Harness #1",
    "text": "Wiring Harness #1\nIt saddens me so greatly that I don’t have an image of this first harness. Sneak Peak: It didn’t work, and it failed epicly. Think, like, slow motion montage of everything falling apart. This was that.\nFirst, I reasoned through some design decisions. I figured that I would want to solder the wires to the display, so that they didn’t easily come off. However, I didn’t want to solder directly to the display pins. That would have left me in an odd spot if I wanted to change anything, or even if I just needed to adjust how the display sat in the housing. So, I snapped off two pieces of 1x9 female PCB headers. I figured that I could plug my display into these two rows, then solder my wires to the through hole pins. Next, I figured I would want to use stranded wire, so avoid fatigue breaks along the wire/solder. After all, I planned to use this guy for the next couple labs – that’s a lot of movement. But, I worried that the stranded wire could easily cause accidental connects once it was shoved up inside the display housing. The through hole pins on the header aren’t that strong either, and could bend together to touch. So, I figured that I would need to add some heat shrink tubing around each connect to make sure it wouldn’t need to be debugged in the future.\nIt is worth noting at this point – I worked for a whole summer where half my job was wire harnesses. I won’t say I love them, because that sounds stupid. But I certainly like them. There is an elegance to an effective harness, and I rarely got to manufacture them myself. So if it sounds like I was going in too deep… I was.\nI wonder if anyone reading this will be able to predict my problem… I certainly wasn’t. First off, the stockroom was out of standard heat shrink tubing in small AWG sizes. They only had these wire-to-wire soldering tubes which fused and protected two separate wires. By cutting these in half and removing the solder in the middle, I was able to get a relatively standard piece of heat shrink tubing. I then got to soldering. I forgot how tricky this could be with stranded wire and only two hands! After an hour or so of soldering a whole PCB header’s worth, I slid my heat shrink down each wire and nestled it in at the base. I headed over to the heat gun that I had found in the analog lab, and turned on low heat.\nInstant problems. The heat shrink tubing I had rigged up apparently had the world’s highest shrinking point. I had to turn the gun up to high and hold it for several seconds to see any change. Do you know what, as it turns out, has a lower melting point? Solder. My solder. The solder I had spend an hour doing. So the whole thing fell apart in front of me.\nThe plastic header was melting. The solder ran in rivers down each pin and pooling in the header. All pins were now one solid contact. The wires fell away as their solder melted. Their jackets dripped down around their frayed and solder-blackened edges. My heat shrink tubes were finally beginning to seal down – around nothing. With the wires gone, they instead sealed off the PCB pins from ever being used again.\nI basically made a really hot, very melted piece of multimedia art that was no longer capable of any useful function. And I am so sad that I did not get a picture of it."
  },
  {
    "objectID": "posts/lab2-post.html#wiring-harness-2",
    "href": "posts/lab2-post.html#wiring-harness-2",
    "title": "Lab 2 Reflection",
    "section": "Wiring Harness #2",
    "text": "Wiring Harness #2\nMy next idea was to use screw terminals as the “header”, or as the connection between display and wire. I figured that I could solder pins to pins and feel relatively confident that they would not make accidental electrical contacts. I could avoid soldering stranded wire entirely, expect maybe to make a solid end to plug into my breadboard.\nThis idea was brilliant. It worked flawlessly. After tragedy, I cannot express how welcome success was. Check out the octopus of wires that now stuck out from my display housing – all perfectly secure and yet removable!\n\nHowever, check out what happened when I tried to plug it in.\n\nI named that image “Rats Nest”. Can you see why?"
  },
  {
    "objectID": "posts/lab2-post.html#migration-to-a-bigger-board",
    "href": "posts/lab2-post.html#migration-to-a-bigger-board",
    "title": "Lab 2 Reflection",
    "section": "Migration to a Bigger Board",
    "text": "Migration to a Bigger Board\nAs soon as I went to actually interface this display with my breadboard, I realized that I was going to have a debugging problem. At this point, I had developed my code enough that I was ready to try running it on an actual display for the first time. I knew that I had thrown my hardware together hastily, anxious to try it out. I had used the only breadboard I had, which was now flying near max capacity. I was confident that if my solution didn’t work the first time, I would have to strip everything down and rewire it on a bigger breadboard. With this scary thought in mind, I plugged it in… and got nothing. Expletive. Pick your favorite.\nJust to drive the point home, this is what I was looking at as I tried to debug my completely non-functional system. I couldn’t get any oscilloscope or multimeter probes anywhere near where I needed them, and following individual wires was like trying to follow an individual spaghetti noodle as you held a wet clump in your hand. But, I have to say, nobody else had a display that floated (as far as I know).\n\nAfter a tedious rewiring, I came to the final hardware solution presented in my Lab 2 report.\nWhat did I learn from this? Ironically, it wasn’t really a lesson learned as much as it was a lesson reminded. I traditionally make overly-neat, meticulously crafted breadboards. I cut each wire to perfect lie-flat length, bend each to fit around and over components, and use my favorite pair of needlenose pliers. What happened this time? Well, partly, I had components which literally floated. I also, however, missed the crucial step of laying out my components beforehand. I didn’t have a good understanding of how many rows I needed, to wire up components like my switches and display resistors. I put myself in a bad situation which I can avoid in the future by completing my design schematic before trying to build out half of it. Additionally, this was a reminder to leave a little wiggle room. My permanent move to a larger board should serve me well in this aspect, but it is worth repeating. I often treat my hardware like I plan to set-it and forget-it. As labs get more complex, this is less realistic."
  },
  {
    "objectID": "posts/lab2-post.html#tragedy-twas-all-for-naught",
    "href": "posts/lab2-post.html#tragedy-twas-all-for-naught",
    "title": "Lab 2 Reflection",
    "section": "Tragedy – ’Twas all for naught",
    "text": "Tragedy – ’Twas all for naught\nAt this point, I had resigned to prototyping on a flat display before trying out my new harness and standalone unit on a working final prototype. Working in lab one day, I heard my friend Alisha laughing at my octopus display. Alisha is one who is likely to strive for excellence marks, so I challenged her: “How did you meet that spec then?”\nShe looked at me with blank eyes and said: “Jackson, what spec? It does not need to be upright.”\nAfter I confirmed with the professor that I had misread the spec, an incredulous me turned into an incredibly disappointed me. At this point, I had invested far more time into the lab than planned, and was no longer on track to finish it by my hopeful Thursday afternoon checkoff. I was willing to pursue the idea when it was an excellence spec, or when it wouldn’t cost me work on next week’s lab – neither condition was true any longer. So, I sadly paused work on my floating octopus and resigned to have my display lie flat like all the others. I resigned to just making sure that the display was “oriented upright to the viewer,” so that digits present themselves in a normal reading manner. Finishing the lab after that was short work – the trickiest part was writing the testbenches. But I lost a lot of flare for it after that. It just wasn’t as exciting any more."
  },
  {
    "objectID": "posts/lab2-post.html#conclusion-and-reflection",
    "href": "posts/lab2-post.html#conclusion-and-reflection",
    "title": "Lab 2 Reflection",
    "section": "Conclusion and Reflection",
    "text": "Conclusion and Reflection\nI think the moral of the story here is that I got overexcited then burnt out too quickly. I still completed a successful lab, albeit way out of the time I had allotted. I still have a great write-up to show for it, and some cool parts that could one day stand alone. I learned a valuable lesson about clarifying specifications at the source, and paying closer attention to when I’m doing something that I don’t see anyone else doing. While that can sometimes be good, it is likely more often a sign that I had missed or misunderstood something. I am, after all, surrounded by some of the best and brightest at Mudd – I am far from the only overzealous one, and certainly not the only one striving to meet all excellence specs.\nIn a more technical sense, I want to get better at writing my testbenches. I did alright this time around, but my display Multiplexer test bench only hit my personal bare minimum. The key thing holding me back here is understanding how to replace the HSOSC module with a testbench generated signal, and understanding how this plays into my test vector readout. I hesitated this time around because I didn’t want to spend forever debugging the testbench alone, rather than the real system. Increasing my proficiency on this front would be a great boon to my EE skills going forward, both in this course and as a practicing professional."
  },
  {
    "objectID": "resources.html",
    "href": "resources.html",
    "title": "Resources",
    "section": "",
    "text": "My Github: Link to Website E155 Course Website: Link to Website"
  }
]